{
    "7a659d90-8571-9d78-d705-4904b6925a9c": {
        "accepts": [], 
        "body": "#!/usr/bin/python\r\n\r\nimport paramiko\r\nimport select\r\nimport socket\r\nimport SocketServer\r\nimport traceback\r\nimport string\r\nimport base64\r\nimport pickle\r\nimport os\r\n\r\nfrom subprocess import Popen, PIPE\r\nfrom time import time, sleep\r\nfrom threading import Thread\r\nfrom random import randrange\r\n\r\nfrom valarie.controller.messaging import add_message\r\nfrom valarie.dao.document import Collection\r\nfrom valarie.dao.utils import sucky_uuid\r\n\r\nclass ForwardServer (SocketServer.ThreadingTCPServer):\r\n    daemon_threads = True\r\n    allow_reuse_address = True\r\n\r\ndef verbose(data):\r\n    output_buffer = \"\"\r\n    for c in data:\r\n        if str(c).isalpha() or \\\r\n           str(c).isdigit() or \\\r\n           str(c) in \"\"\"`~!@#$%^&*()_+-=\\][|}{';\":/.,?>< \"\"\":\r\n            output_buffer += c\r\n        else:\r\n            output_buffer += '.'\r\n    #add_message(output_buffer)\r\n\r\nclass Handler (SocketServer.BaseRequestHandler):\r\n    def handle(self):\r\n        verbose('Connecting SSH Tunnel...')\r\n        \r\n        try:\r\n            chan = self.ssh_transport.open_channel('direct-tcpip',\r\n                                                   (self.chain_host, self.chain_port),\r\n                                                   self.request.getpeername())\r\n        except Exception as e:\r\n            verbose('Incoming request to %s:%d failed: %s' % (self.chain_host,\r\n                                                              self.chain_port,\r\n                                                              repr(e)))\r\n            return\r\n        if chan is None:\r\n            verbose('Incoming request to %s:%d was rejected by the SSH server.' %\r\n                    (self.chain_host, self.chain_port))\r\n            return\r\n\r\n        verbose('Connected!  Tunnel open %r -> %r -> %r' % (self.request.getpeername(),\r\n                                                            chan.getpeername(), (self.chain_host, self.chain_port)))\r\n        \r\n        while True:\r\n            r, w, x = select.select([self.request, chan], [], [])\r\n            if self.request in r:\r\n                data = self.request.recv(48)\r\n                if len(data) > 0:\r\n                    verbose(\"Tunnel: SEND {1} bytes : [{0}]\".format(data, len(data)))\r\n                    chan.send(data)\r\n                else:\r\n                    sleep(1)\r\n\r\n            if chan in r:\r\n                data = chan.recv(48)\r\n                if len(data) > 0:\r\n                    verbose(\"Tunnel: RECV {1} bytes : [{0}]\".format(data, len(data)))    \r\n                    self.request.send(data)\r\n                else:\r\n                    sleep(1)\r\n                \r\n        peername = self.request.getpeername()\r\n        chan.close()\r\n        self.request.close()\r\n        verbose('Tunnel closed from %r' % (peername,))\r\n\r\nclass Console:\r\n    def __init__(self, **kargs):\r\n        # Private Members\r\n        self.__ssh = paramiko.SSHClient()\r\n        self.__username = \"username\"\r\n        self.__password = \"password\"\r\n        self.__private_key = None\r\n        self.__remote = kargs[\"host\"][\"host\"]\r\n        self.__session_var = {}\r\n        self.__tunnel = {}\r\n        \r\n        # Public Members\r\n        self.sftp = None\r\n        \r\n        self.connect()\r\n        \r\n        self.__chan = self.__ssh.invoke_shell()\r\n\r\n    #### Mutation Methods ########################\r\n    def set_username(self, username):\r\n        self.__username = username\r\n        \r\n    def set_password(self, password):\r\n        self.__password = password\r\n    \r\n    def set_private_key(self, key_filename, password = None):\r\n        self.__private_key = paramiko.RSAKey.from_private_key_file(key_filename, password = password)\r\n\r\n    def set_remote_host(self, remote):\r\n        self.__remote = remote\r\n    \r\n    #### Set Key Value ###########################\r\n    def set(self, key, value):\r\n        try:\r\n            self.__session_var[key] = value\r\n        except Exception:\r\n            self.__session_var = {}\r\n            self.__session_var[key] = value\r\n    \r\n    #### Inspection Methods ######################\r\n    def get_username(self):\r\n        return self.__username\r\n    \r\n    def get_password(self):\r\n        return self.__password\r\n    \r\n    def get_remote_host(self):\r\n        return self.__remote\r\n    \r\n    #### Get Key Value ###########################\r\n    # Return key value. If a key error exception is thrown, return none.\r\n    def get(self, key):\r\n        try:\r\n            value = self.__session_var[key]\r\n            return value\r\n        except Exception as e:\r\n            return None\r\n    \r\n    #### Test sudo ###############################\r\n    # Test sudo by sudoing whoami. Credentials are fed into standard input and\r\n    # flushed after executing sudo. If a non-zero return code is recieved a\r\n    # custom exception is raised.\r\n    def __test_sudo(self):\r\n        if not self.__username == \"root\":\r\n            stdin, stdout, stderr = self.__ssh.exec_command('sudo -S whoami')\r\n            stdin.write(self.__password + '\\n')\r\n            stdin.flush()\r\n            if 0 != int(stdout.channel.recv_exit_status()):\r\n                raise NameError('Sudo test failed with {0}@{1}'.format(self.__username, self.__remote))\r\n    \r\n    #### Connect to SSH Server ###################\r\n    # Set host key policy to AutoAddPolicy() and connect to host using credentials\r\n    # from private members. Finally test sudo.\r\n    def connect(self):\r\n        self.__ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\r\n        if self.__private_key:        \r\n            self.__ssh.connect(self.__remote, username = self.__username, pkey = self.__private_key)\r\n        else:\r\n            self.__ssh.connect(self.__remote, username = self.__username, password = self.__password)\r\n        self.__ssh.get_transport().set_keepalive(30)\r\n        self.sftp = self.__ssh.open_sftp()\r\n    \r\n    #### Close Connection ########################\r\n    # Close SFTP and SSH connections\r\n    def close(self):\r\n        self.sftp.close()\r\n        self.__ssh.close()\r\n    \r\n    #### Get Shell ###############################\r\n    # Return channel object for an interactive shell\r\n    def get_shell(self):\r\n        return self.__ssh.invoke_shell()\r\n    \r\n    #### Run Script ##############################\r\n    # Run script. The header remarks of the file\r\n    # is used to determine what interpreter or \r\n    # program should be used. The script is \r\n    # selected with its inventory object UUID.\r\n    # The start directory, user to run as, and\r\n    # return format are optional parameters.\r\n    def script(self, \\\r\n               objuuid = None, \\\r\n               body = None, \\\r\n               start_directory = None, \\\r\n               run_as = None, \\\r\n               return_tuple = False):\r\n        if objuuid != None:\r\n            script = Collection(\"inventory\").get_object(objuuid)\r\n            script_name = script.object[\"name\"]\r\n            script_body = script.object[\"body\"]\r\n        elif body != None:\r\n            script_name = \"valarie-\" + sucky_uuid()\r\n            script_body = body\r\n        else:\r\n            raise Exception(\"No objuuid or script body specified!\")\r\n\r\n        file = self.sftp.open(script_name, \"w\") \r\n        file.write(script_body)\r\n        file.close()\r\n        \r\n        self.system(\"chmod 755 {0}\".format(script_name))\r\n        \r\n        if start_directory == None:\r\n            if run_as == None:\r\n                status, stdout, stderr = self.system(\"./{0}\".format(script_name), \\\r\n                                                     return_tuple = True)\r\n            else:\r\n                status, stdout, stderr = self.system(\"sudo -u {1} ./{0}\". \\\r\n                                                     format(script_name, \\\r\n                                                            run_as), \\\r\n                                                     return_tuple = True)\r\n            \r\n            self.system(\"rm -f {0}\".format(script_name))\r\n        else:\r\n            self.system(\"mv -f {0} /{1}/{2}\".format(script_name, \\\r\n                                                    start_directory, \\\r\n                                                    script_name))\r\n            if run_as == None:\r\n                status, stdout, stderr = self.system(\"bash -c 'cd {0}; ./{1}'\". \\\r\n                                                     format(start_directory, \\\r\n                                                            script_name), \\\r\n                                                     return_tuple = True)\r\n            else:\r\n                status, stdout, stderr = self.system(\"sudo -u {2} bash -c 'cd {0}; ./{1}'\". \\\r\n                                                     format(start_directory, \\\r\n                                                            script_name, \\\r\n                                                            run_as), \\\r\n                                                     return_tuple = True)\r\n            \r\n            self.system(\"rm -f /{0}/{1}\".format(start_directory, script_name))\r\n        \r\n        if return_tuple == True:\r\n            return status, stdout, stderr\r\n        else:\r\n            return stdout + stderr\r\n\r\n    #### System Command ##########################\r\n    # Execute command on SSHClient. If the credentials has a user other than root\r\n    # append the command into a sudo command. If redirection is used with sudo,\r\n    # run the command in its own bash shell to preserve privileges while\r\n    # redirecting to a file. If __debug is set to true, print all three I/O\r\n    # streams during execution. If a non-zero exit code is returned, tag the\r\n    # standard error buffer as red font and add it to the output buffer. If the\r\n    # return tuple parameter is set to true, a tuple of the exit status, standard\r\n    # output buffer, and standard error buffer is returned.\r\n    def system(self, command, return_tuple = False, sudo_command = True):\r\n        if self.__username == \"root\" or not sudo_command:\r\n            stdin, stdout, stderr = self.__ssh.exec_command(command)\r\n        else:\r\n            if \" > \" in command or \" >> \" in command:\r\n                stdin, stdout, stderr = self.__ssh.exec_command(\"sudo -S bash -c '{0}'\".format(command))\r\n            else:\r\n                stdin, stdout, stderr = self.__ssh.exec_command('sudo -S ' + command)\r\n            stdin.write(self.__password + '\\n')\r\n            stdin.flush()\r\n\r\n        # Lossy ascii character set conversion\r\n        output_buffer = \"\"\r\n        for c in stdout.read().replace(\"[sudo] password for {0}:\".format(self.__username), \"\"):\r\n            try:\r\n                output_buffer += c.encode(\"ascii\", \"ignore\")\r\n            except Exception:\r\n                pass\r\n\r\n        # Lossy ascii character set conversion\r\n        stderr_buffer = \"\"\r\n        for c in stderr.read().replace(\"[sudo] password for {0}:\".format(self.__username), \"\"):\r\n            try:\r\n                stderr_buffer += c.encode(\"ascii\", \"ignore\")\r\n            except Exception:\r\n                pass\r\n        \r\n        status = stdout.channel.recv_exit_status()\r\n        \r\n        if return_tuple:\r\n            return status, output_buffer, stderr_buffer\r\n        elif 0 != int(status):\r\n            return '{0}<font color=\"red\"><br>{1}</font><br>'.format(output_buffer, stderr_buffer)\r\n        else:\r\n            return output_buffer\r\n    \r\n    #### SSH Tunnel ##############################\r\n    # Methods for starting and stopping SSH tunnels. \r\n    def __start_tunnel(self, local_port, remote_host, remote_port):\r\n        transport = self.__ssh.get_transport()\r\n        class SubHandler (Handler):\r\n            chain_host = remote_host\r\n            chain_port = remote_port\r\n            ssh_transport = transport\r\n        self.__tunnel[local_port] = ForwardServer(('', local_port), SubHandler)\r\n        self.__tunnel[local_port].serve_forever()\r\n    \r\n    def start_tunnel(self, local_port, remote_host, remote_port):    \r\n        Thread(target = self.__start_tunnel, args = (local_port, remote_host, remote_port)).start()\r\n        sleep(5)\r\n    \r\n    def stop_tunnel(self, local_port):\r\n        if local_port in self.__tunnel:\r\n            self.__tunnel[local_port].shutdown()\r\n            del self.__tunnel[local_port]\r\n    \r\n    def send(self, input_buffer):\r\n        for c in input_buffer:\r\n            self.__chan.send(c)\r\n    \r\n    def recv(self):\r\n        if self.__chan.recv_ready():\r\n            return self.__chan.recv(9999)\r\n        elif self.__chan.recv_stderr_ready():\r\n            return self.__chan.recv_stderr(9999)\r\n        else:\r\n            return ''\r\n    \r\n    def writef(self, filename, body):\r\n        f = self.sftp.file(filename, mode = \"w\")\r\n        f.write(body)\r\n        f.close()\r\n    \r\n    def writebf(self, filename, body):\r\n        f = self.sftp.file(filename, mode = \"wb\")\r\n        f.write(body)\r\n        f.close()\r\n    \r\n    def readf(self, filename):\r\n        f = self.sftp.file(filename, mode = \"r\")\r\n        body = str(f.read())\r\n        f.close()\r\n        return body\r\n    \r\n    def readbf(self, filename):\r\n        f = self.sftp.file(filename, mode = \"rb\")\r\n        body = f.read()\r\n        f.close()\r\n        return body\r\n\r\n    def putf(self, file):\r\n        self.send(\"echo Uploading {0}...\\n\".format(file.filename))\r\n        self.sftp.putfo(file.file, file.filename)\r\n", 
        "changed": false, 
        "children": [], 
        "coluuid": "25adc998-7112-4670-67ab-3ad78a94e9ca", 
        "context": {
            "copy": {
                "action": {
                    "method": "copy node", 
                    "params": {
                        "objuuid": "7a659d90-8571-9d78-d705-4904b6925a9c"
                    }, 
                    "route": "inventory/ajax_copy_object"
                }, 
                "label": "Copy"
            }, 
            "delete": {
                "action": {
                    "method": "delete node", 
                    "params": {
                        "objuuid": "7a659d90-8571-9d78-d705-4904b6925a9c"
                    }, 
                    "route": "inventory/ajax_delete"
                }, 
                "label": "Delete"
            }, 
            "edit": {
                "action": {
                    "method": "edit console", 
                    "params": {
                        "objuuid": "7a659d90-8571-9d78-d705-4904b6925a9c"
                    }, 
                    "route": "inventory/ajax_get_object"
                }, 
                "label": "Edit"
            }
        }, 
        "icon": "/images/console_icon.png", 
        "name": "SSH", 
        "objuuid": "7a659d90-8571-9d78-d705-4904b6925a9c", 
        "parent": "69b4d682-21e5-12a1-2771-d14b728a57bb", 
        "type": "console"
    }
}